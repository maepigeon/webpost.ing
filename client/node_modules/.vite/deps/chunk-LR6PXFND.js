import {
  $getRoot,
  $isElementNode
} from "./chunk-HWY6QIMS.js";

// node_modules/@lexical/utils/LexicalUtils.dev.mjs
function formatDevErrorMessage(message) {
  throw new Error(message);
}
var CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
var IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
var IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;
function normalizeClassNames(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s] of className.matchAll(/\S+/g)) {
        rval.push(s);
      }
    }
  }
  return rval;
}
function mergeRegister(...func) {
  return () => {
    for (let i = func.length - 1; i >= 0; i--) {
      func[i]();
    }
    func.length = 0;
  };
}
var CAN_USE_DOM = CAN_USE_DOM$1;
var IS_FIREFOX = IS_FIREFOX$1;
function addClassNamesToElement(element, ...classNames) {
  const classesToAdd = normalizeClassNames(...classNames);
  if (classesToAdd.length > 0) {
    element.classList.add(...classesToAdd);
  }
}
function removeClassNamesFromElement(element, ...classNames) {
  const classesToRemove = normalizeClassNames(...classNames);
  if (classesToRemove.length > 0) {
    element.classList.remove(...classesToRemove);
  }
}
function $getNearestNodeOfType(node, klass) {
  let parent = node;
  while (parent != null) {
    if (parent instanceof klass) {
      return parent;
    }
    parent = parent.getParent();
  }
  return null;
}
function $getNearestBlockElementAncestorOrThrow(startNode) {
  const blockNode = $findMatchingParent(startNode, (node) => $isElementNode(node) && !node.isInline());
  if (!$isElementNode(blockNode)) {
    {
      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);
    }
  }
  return blockNode;
}
var $findMatchingParent = (startingNode, findFn) => {
  let curr = startingNode;
  while (curr !== $getRoot() && curr != null) {
    if (findFn(curr)) {
      return curr;
    }
    curr = curr.getParent();
  }
  return null;
};
function objectKlassEquals(object, objectClass) {
  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}
var NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : void 0;
function needsManualZoom() {
  if (NEEDS_MANUAL_ZOOM === void 0) {
    const div = document.createElement("div");
    div.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;";
    document.body.appendChild(div);
    const noZoom = div.getBoundingClientRect();
    div.style.setProperty("zoom", "2");
    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;
    document.body.removeChild(div);
  }
  return NEEDS_MANUAL_ZOOM;
}
function calculateZoomLevel(element) {
  let zoom = 1;
  if (needsManualZoom()) {
    while (element) {
      zoom *= Number(window.getComputedStyle(element).getPropertyValue("zoom"));
      element = element.parentElement;
    }
  }
  return zoom;
}

export {
  mergeRegister,
  addClassNamesToElement,
  removeClassNamesFromElement,
  $getNearestNodeOfType,
  $getNearestBlockElementAncestorOrThrow,
  $findMatchingParent,
  objectKlassEquals,
  calculateZoomLevel
};
//# sourceMappingURL=chunk-LR6PXFND.js.map
